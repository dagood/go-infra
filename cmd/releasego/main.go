// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

package main

import (
	"context"
	"flag"
	"log"
	"strings"

	"github.com/google/go-github/github"
	"github.com/microsoft/go-infra/azdo"
	"github.com/microsoft/go-infra/githubutil"
	"github.com/microsoft/go-infra/goversion"
	"github.com/microsoft/go-infra/subcmd"
)

const description = `
releasego runs various parts of a release of microsoft/go. The subcommands implement the steps.
`

// subcommands is the list of subcommand options, populated by each file's init function.
var subcommands []subcmd.Option

func main() {
	if err := subcmd.Run("releasego", description, subcommands); err != nil {
		log.Fatal(err)
	}
}

func tagFlag() *string {
	return flag.String("tag", "", "[Required] The tag name.")
}

// versionBranch determines the upstream branch that a given release version belongs to.
func versionBranch(v *goversion.GoVersion) string {
	branchBase := "release-branch.go"
	if v.Note == "fips" {
		branchBase = "dev.boringcrypto.go"
	}
	return branchBase + v.MajorMinor()
}

// appendPathAndVerificationFilePaths appends to p the path and the verification file (hash,
// signature) paths that should be available along with the file at path. This can be used to
// calculate what URLs should be available for a given build artifact URL.
func appendPathAndVerificationFilePaths(p []string, path string) []string {
	p = append(p, path, path+".sha256")
	if strings.HasSuffix(path, ".tar.gz") {
		p = append(p, path+".sig")
	}
	return p
}

// docPointerMarkdown is a pointer to the release process docs with some context, as markdown text.
const docPointerMarkdown = "For more information about the microsoft/go release process, see [docs/release-process in microsoft/go-infra](https://github.com/microsoft/go-infra/tree/main/docs/release-process)."

var releaseIssueLabels = []string{"Area-Release"}

func createReleaseIssue(pat, repo, title, message string) (int, error) {
	owner, name, err := githubutil.ParseRepoFlag(&repo)
	if err != nil {
		return 0, err
	}

	ctx := context.Background()
	client, err := githubutil.NewClient(ctx, pat)
	if err != nil {
		return 0, err
	}

	message += "\n\n" + docPointerMarkdown

	if url := azdo.GetEnvBuildURL(); url != "" {
		message += "\n\nThis comment was generated by: [" + azdo.GetEnvBuildID() + "](" + url + ")"
	}

	log.Printf("Creating comment on %v/%v with title %#q and content:\n%v\n", owner, name, title, message)

	var c *github.Issue
	err = githubutil.Retry(func() error {
		var err error
		c, _, err = client.Issues.Create(ctx, owner, name, &github.IssueRequest{
			Title:  &title,
			Body:   &message,
			Labels: &releaseIssueLabels,
		})
		if err != nil {
			return err
		}
		log.Printf("Link to issue: %v\n", *c.HTMLURL)
		return nil
	})
	if err != nil {
		return 0, err
	}
	return *c.Number, nil
}
