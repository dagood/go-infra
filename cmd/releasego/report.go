// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

package main

import (
	"context"
	_ "embed"
	"encoding/json"
	"errors"
	"flag"
	"fmt"
	"log"
	"sort"
	"strings"
	"time"

	"github.com/google/go-github/github"
	"github.com/microsoft/go-infra/azdo"
	"github.com/microsoft/go-infra/githubutil"
	"github.com/microsoft/go-infra/subcmd"
)

func init() {
	subcommands = append(subcommands, subcmd.Option{
		Name:        "report",
		Summary:     "Report release build's status to a GitHub issue",
		Description: "\n\n" + azdo.AzDOBuildDetectionDoc,
		Handle:      handleReport,
	})
}

const reportDataMarker = "section generated by go-infra './cmd/releasego report'."
const beginReportDataMarker = "<!-- BEGIN " + reportDataMarker + " -->"
const endReportDataMarker = "<!-- END " + reportDataMarker + " -->"

const reportBuildFailSymbol = "‚ùå"

const reportRetryTimeoutDuration = 5 * time.Minute
const reportRetryDelayDuration = 5 * time.Second

func handleReport(p subcmd.ParseFunc) error {
	repo := githubutil.BindRepoFlag()
	pat := githubutil.BindPATFlag()
	issue := flag.Int("i", 0, "[Required] The issue number to add the comment to.")

	fromEnv := flag.Bool(
		"azdoenv", false,
		"Gather information from Azure Pipelines predefined env variables.\n"+
			"If more specific info flags are used they override this env info.")

	status := flag.String("build-status", "", "The current Agent.JobStatus value.")
	buildID := flag.String("build-id", "", "The build ID to report.")
	buildPipeline := flag.String("build-pipeline", "", "The name of the build pipeline.")
	start := flag.Bool("build-start", false, "Assign the current time as the start time of the reported build.")

	version := flag.String(
		"version", "",
		"[Required] A full microsoft/go version number (major.minor.patch-revision[-suffix]).\n"+
			"This is used to categorize the list of builds in a release issue.")

	if err := p(); err != nil {
		return err
	}

	if *issue == 0 {
		return errors.New("no issue specified")
	}
	if *status == "" {
		return errors.New("no status specified")
	}
	if *version == "" {
		return errors.New("no version specified")
	}

	owner, name, err := githubutil.ParseRepoFlag(repo)
	if err != nil {
		return err
	}

	report := buildReport{
		Version:    *version,
		LastUpdate: time.Now().UTC(),
	}
	if *fromEnv {
		report.readEnv()
	}
	if *buildID != "" {
		report.BuildID = *buildID
	}
	if *buildPipeline != "" {
		report.BuildPipeline = *buildPipeline
	}
	if *status != "" {
		report.Status = *status
	}
	if *start {
		report.StartTime = report.LastUpdate
	}

	log.Printf("Reporting %#v\n", report)

	ctx := context.Background()
	client, err := githubutil.NewClient(ctx, *pat)
	if err != nil {
		return err
	}

	startTime := time.Now()
	for {
		elapsed := time.Now().Sub(startTime)
		if elapsed > reportRetryTimeoutDuration {
			return fmt.Errorf("retry timeout %v expended", reportRetryTimeoutDuration)
		}

		// githubutil.Retry is designed to handle infra flakiness and rate limiting. We want this,
		// but we also want to handle potential concurrency issues. So: use two layers of retry.
		err := githubutil.Retry(func() error {
			issueData, _, err := client.Issues.Get(ctx, owner, name, *issue)
			if err != nil {
				return err
			}

			rc := parseReportComment(issueData.GetBody())
			rc.update(report.present())
			body, err := rc.body()
			if err != nil {
				return fmt.Errorf("unable to generate issue body: %v", err)
			}

			edit, _, err := client.Issues.Edit(ctx, owner, name, *issue, &github.IssueRequest{
				Body: &body,
			})
			if err != nil {
				return err
			}
			log.Printf("Edit: %v\n", edit)
			return nil
		})
		if err != nil {
			// Inner retry wasn't able to get the update done. This may be due to concurrency: N
			// builds trying to update the issue at the same time. Try again after a short delay.
			// (Nothing fancy: we aren't concerned about capacity contention. Even in the worst case
			// of N updates happening simultaneously, repeatedly, all concurrent updates will
			// eventually be able to get through because one update out of N succeeds each time.)
			fmt.Printf(
				"Inner GitHub retry loop failed. Waiting %v then trying again. Will give up after %v. Error: %v\n",
				reportRetryDelayDuration,
				reportRetryDelayDuration-elapsed,
				err)
			time.Sleep(reportRetryDelayDuration)
			continue
		}
		break // Success.
	}

	return githubutil.Retry(func() error {
		updateMessage := "Updated"

		c, _, err := client.Issues.CreateComment(
			ctx, owner, name, *issue, &github.IssueComment{Body: &updateMessage})
		if err != nil {
			return err
		}
		log.Printf("Comment: %v\n", *c.HTMLURL)
		return nil
	})

}

type buildReportPresentation struct {
	buildReport

	BuildURL    string
	BuildSymbol string
}

type buildReport struct {
	BuildID         string
	BuildPipeline   string
	BuildCollection string
	BuildProject    string
	Status          string

	Version    string
	LastUpdate time.Time
	StartTime  time.Time
}

func newBuildReport(version string) *buildReport {
	return &buildReport{
		Version:    version,
		LastUpdate: time.Now().UTC(),
	}
}

func (b *buildReport) readEnv() {
	b.BuildID = azdo.GetEnvBuildID()
	b.BuildPipeline = azdo.GetEnvDefinitionName()
	b.BuildCollection = azdo.GetEnvCollectionURI()
	b.BuildProject = azdo.GetEnvProject()
	b.Status = azdo.GetEnvAgentJobStatus()
}

func (b *buildReport) present() buildReportPresentation {
	p := buildReportPresentation{
		buildReport: *b,
		BuildURL:    azdo.GetBuildURL(b.BuildCollection, b.BuildProject, b.BuildID),
	}
	switch b.Status {
	// Handle possible AzDO env values.
	case "Succeeded", "SucceededWithIssues":
		p.BuildSymbol = "‚úÖ"
	case "Canceled", "Failed":
		p.BuildSymbol = reportBuildFailSymbol
	// Handle values that are passed in manually, not provided by Agent.JobStatus.
	case "InProgress":
		p.BuildSymbol = "üèÉ"
	case "NotStarted":
		p.BuildSymbol = "‚åö"
	}
	return p
}

type reportComment struct {
	before, after string
	reports       []buildReportPresentation
}

func parseReportComment(body string) reportComment {
	before, report, after, found := cutTwice(body, beginReportDataMarker, endReportDataMarker)
	if found {
		if _, data, _, found := cutTwice(report, "<!-- DATA ", " DATA -->"); found {
			r := make([]buildReportPresentation, 0) // Unmarshal doesn't accept nil.
			err := json.Unmarshal([]byte(data), &r)
			if err != nil {
				log.Printf("Unable to read report data from comment: %v\n%v\n", err, data)
			}
			return reportComment{before, after, r}
		}
	}
	// Either the BEGIN/END markers couldn't be found, or DATA couldn't be found. Treat the comment
	// as either a fresh issue or corrupted. Keep all the text, but remove the markers so a future
	// report parse doesn't get confused by multiple markers being present.
	return reportComment{
		before: before,
		after:  after,
	}
}

func (r *reportComment) update(report buildReportPresentation) {
	found := false
	for i, existingReport := range r.reports {
		if existingReport.BuildID == report.BuildID {
			r.reports[i] = report.present()
			found = true
			break
		}
	}
	if !found {
		r.reports = append(r.reports, report.present())
	}
}

func (r *reportComment) body() (string, error) {
	var b strings.Builder
	b.WriteString(r.before)
	b.WriteString(beginReportDataMarker)

	sort.SliceStable(r.reports, func(i, j int) bool {
		iv, jv := r.reports[i], r.reports[j]
		if c := strings.Compare(iv.Version, jv.Version); c != 0 {
			return c < 0
		}
		if c := strings.Compare(iv.BuildPipeline, jv.BuildPipeline); c != 0 {
			return c < 0
		}
		if c := strings.Compare(iv.BuildID, jv.BuildID); c != 0 {
			return c < 0
		}
		return false
	})

	var version, pipeline string
	// Always start a new table for the first report, even if it has no version or no pipeline.
	newTable := true
	for _, report := range r.reports {
		if report.Version != version {
			version = report.Version
			b.WriteString("\n## ")
			b.WriteString(version)
			b.WriteString("\n")
			pipeline = ""
			newTable = true
		}
		if report.BuildPipeline != pipeline {
			pipeline = report.BuildPipeline
			b.WriteString("\n### ")
			b.WriteString(pipeline)
			b.WriteString("\n\n")
			newTable = true
		}
		if newTable {
			newTable = false
			b.WriteString("Build ID | Status | Started | Last Report\n")
			b.WriteString("--- | --- | --- | ---\n")
		}
		b.WriteString("[")
		b.WriteString(report.BuildID)
		b.WriteString("](")
		b.WriteString(report.BuildURL)
		b.WriteString(")")
		b.WriteString(" | ")
		b.WriteString(report.Status)
		if report.BuildSymbol == reportBuildFailSymbol {
			b.WriteString(", [Retry](")
			b.WriteString(report.BuildURL)
			b.WriteString("&view=ms.vss-build-web.run-extensions-tab)")
		}
		b.WriteString(" | ")
		b.WriteString(report.StartTime.Format("2006-01-02 15:04"))
		b.WriteString(" | ")
		b.WriteString(report.LastUpdate.Format("2006-01-02 15:04"))
		b.WriteString("\n")
	}
	b.WriteString("\n")

	b.WriteString("<!-- DATA ")
	bytes, err := json.MarshalIndent(r.reports, "", "  ")
	if err != nil {
		b.WriteString("[]")
	} else {
		b.Write(bytes)
	}
	b.WriteString(" DATA -->")

	b.WriteString(endReportDataMarker)
	b.WriteString(r.after)
	return b.String(), nil
}

func cutTwice(content, sep1, sep2 string) (before, between, after string, found bool) {
	if before1, after1, found := strings.Cut(content, sep1); found {
		if between, after2, found := strings.Cut(after1, sep2); found {
			return before1, between, after2, true
		}
	}
	return content, "", "", false
}
