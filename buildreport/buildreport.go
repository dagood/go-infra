// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

package buildreport

import (
	"context"
	_ "embed"
	"encoding/json"
	"fmt"
	"log"
	"sort"
	"strings"
	"time"

	"github.com/google/go-github/github"
	"github.com/microsoft/go-infra/githubutil"
)

const (
	FailedSymbol     = "‚ùå"
	SuccessSymbol    = "‚úÖ"
	InProgressSymbol = "üèÉ"
	NotStartedSymbol = "‚åö"
)

const dataSectionMarker = "section generated by go-infra './cmd/releasego report'."
const beginDataSectionMarker = "<!-- BEGIN " + dataSectionMarker + " -->"
const endDataSectionMarker = "<!-- END " + dataSectionMarker + " -->"

const beginDataMarker = "<!-- DATA "
const endDataMarker = " DATA -->"

const reportRetryTimeoutDuration = 5 * time.Minute
const reportRetryDelayDuration = 5 * time.Second

func UpdateIssue(ctx context.Context, owner, repoName, pat string, issue int, s State) error {
	client, err := githubutil.NewClient(ctx, pat)
	if err != nil {
		return err
	}

	startTime := time.Now()
	for {
		elapsed := time.Now().Sub(startTime)
		if elapsed > reportRetryTimeoutDuration {
			return fmt.Errorf("retry timeout %v expended", reportRetryTimeoutDuration)
		}

		// githubutil.Retry is designed to handle infra flakiness and rate limiting. We want this,
		// but we also want to handle potential concurrency issues. So: use two layers of retry.
		err := githubutil.Retry(func() error {
			issueData, _, err := client.Issues.Get(ctx, owner, repoName, issue)
			if err != nil {
				return err
			}

			rc := parseReportComment(issueData.GetBody())
			rc.update(s)
			body, err := rc.body()
			if err != nil {
				return fmt.Errorf("unable to generate issue body: %v", err)
			}

			edit, _, err := client.Issues.Edit(ctx, owner, repoName, issue, &github.IssueRequest{
				Body: &body,
			})
			if err != nil {
				return err
			}
			log.Printf("Edit: %v\n", edit)
			return nil
		})
		if err != nil {
			// Inner retry wasn't able to get the update done. This may be due to concurrency: N
			// builds trying to update the issue at the same time. Try again after a short delay.
			// (Nothing fancy: we aren't concerned about capacity contention. Even in the worst case
			// of N updates happening simultaneously, repeatedly, all concurrent updates will
			// eventually be able to get through because one update out of N succeeds each time.)
			log.Printf(
				"Inner GitHub retry loop failed. Waiting %v then trying again. Will give up after %v. Error: %v\n",
				reportRetryDelayDuration,
				reportRetryDelayDuration-elapsed,
				err)
			time.Sleep(reportRetryDelayDuration)
			continue
		}
		break // Success.
	}
	return nil
}

type State struct {
	Version       string
	BuildPipeline string
	BuildID       string
	BuildURL      string

	BuildSymbol string
	LastUpdate  time.Time
	StartTime   time.Time
}

type commentBody struct {
	before, after string
	reports       []State
}

func parseReportComment(body string) commentBody {
	before, report, after, found := cutTwice(body, beginDataSectionMarker, endDataSectionMarker)
	if found {
		if _, data, _, found := cutTwice(report, beginDataMarker, endDataMarker); found {
			r := make([]State, 0) // Unmarshal doesn't accept nil.
			err := json.Unmarshal([]byte(data), &r)
			if err != nil {
				log.Printf("Unable to read report data from comment: %v\n%v\n", err, data)
			}
			return commentBody{before, after, r}
		}
	}
	// Either the BEGIN/END markers couldn't be found, or DATA couldn't be found. Keep before and
	// after (if found), but ignore the content of the data section (if any).
	return commentBody{
		before: before,
		after:  after,
	}
}

func (c *commentBody) update(report State) {
	found := false
	for i := range c.reports {
		r := &c.reports[i]
		if r.BuildID == report.BuildID {
			// Update the found report by copying non-default fields.
			if report.Version != "" {
				r.Version = report.Version
			}
			if report.BuildPipeline != "" {
				r.BuildPipeline = report.BuildPipeline
			}
			if report.BuildURL != "" {
				r.BuildURL = report.BuildURL
			}
			if report.BuildSymbol != "" {
				r.BuildSymbol = report.BuildSymbol
			}
			if report.LastUpdate != (time.Time{}) {
				r.LastUpdate = report.LastUpdate
			}
			if report.StartTime != (time.Time{}) {
				r.StartTime = report.StartTime
			}
			found = true
			break
		}
	}
	if !found {
		c.reports = append(c.reports, report)
	}
}

func (c *commentBody) body() (string, error) {
	var b strings.Builder
	b.WriteString(c.before)
	b.WriteString(beginDataSectionMarker)

	sort.SliceStable(c.reports, func(i, j int) bool {
		iv, jv := c.reports[i], c.reports[j]
		if c := strings.Compare(iv.Version, jv.Version); c != 0 {
			return c < 0
		}
		if c := strings.Compare(iv.BuildPipeline, jv.BuildPipeline); c != 0 {
			return c < 0
		}
		if c := strings.Compare(iv.BuildID, jv.BuildID); c != 0 {
			return c < 0
		}
		return false
	})

	var version, pipeline string
	// Always start a new table for the first report, even if it has no version or no pipeline.
	newTable := true
	for _, r := range c.reports {
		if r.Version != version {
			version = r.Version
			b.WriteString("\n## ")
			b.WriteString(version)
			b.WriteString("\n")
			pipeline = ""
			newTable = true
		}
		if r.BuildPipeline != pipeline {
			pipeline = r.BuildPipeline
			b.WriteString("\n### ")
			b.WriteString(pipeline)
			b.WriteString("\n\n")
			newTable = true
		}
		if newTable {
			newTable = false
			b.WriteString("| Build ID | Status | Started | Last Report |\n")
			b.WriteString("| --- | --- | --- | --- |\n")
		}
		b.WriteString("| ")
		b.WriteString("[")
		b.WriteString(r.BuildID)
		b.WriteString("](")
		b.WriteString(r.BuildURL)
		b.WriteString(")")
		b.WriteString(" | ")
		b.WriteString(r.BuildSymbol)
		// If the build has failed (potentially needs retry) and is a release infra build (likely
		// publishes retry information), then show a direct link. This detection might not be 100%
		// accurate, but it's just a small convenience: it's ok to rely on a heuristic string match.
		if r.BuildSymbol == FailedSymbol && strings.HasPrefix(r.BuildPipeline, "microsoft-go-infra-release-") {
			b.WriteString(" [Retry](")
			b.WriteString(r.BuildURL)
			b.WriteString("&view=ms.vss-build-web.run-extensions-tab)")
		}
		b.WriteString(" | ")
		if r.StartTime != (time.Time{}) {
			b.WriteString(r.StartTime.Format("2006-01-02 15:04"))
		}
		b.WriteString(" | ")
		if r.LastUpdate != (time.Time{}) {
			b.WriteString(r.LastUpdate.Format("2006-01-02 15:04"))
		}
		b.WriteString(" |")
		b.WriteString("\n")
	}
	b.WriteString("\n")

	b.WriteString(beginDataMarker)
	bytes, err := json.MarshalIndent(c.reports, "", "  ")
	if err != nil {
		b.WriteString("[]")
	} else {
		b.Write(bytes)
	}
	b.WriteString(endDataMarker)
	b.WriteString("\n")

	b.WriteString(endDataSectionMarker)
	b.WriteString(c.after)
	return b.String(), nil
}

func SingleStateBody(s *State) (string, error) {
	c := commentBody{reports: []State{*s}}
	return c.body()
}

func cutTwice(content, sep1, sep2 string) (before, between, after string, found bool) {
	if before1, after1, found := strings.Cut(content, sep1); found {
		if between, after2, found := strings.Cut(after1, sep2); found {
			return before1, between, after2, true
		}
	}
	return content, "", "", false
}
