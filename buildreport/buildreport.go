// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

package buildreport

import (
	"context"
	_ "embed"
	"encoding/json"
	"fmt"
	"log"
	"sort"
	"strings"
	"time"

	"github.com/google/go-github/github"
	"github.com/microsoft/go-infra/githubutil"
)

type ReportSymbol string

const (
	ReportSymbolFailed     ReportSymbol = "‚ùå"
	ReportSymbolSucceeded               = "‚úÖ"
	ReportSymbolInProgress              = "üèÉ"
	ReportSymbolNotStarted              = "‚åö"
)

const dataSectionMarker = "section generated by go-infra './cmd/releasego report'."
const beginDataSectionMarker = "<!-- BEGIN " + dataSectionMarker + " -->"
const endDataSectionMarker = "<!-- END " + dataSectionMarker + " -->"

const beginDataMarker = "<!-- DATA "
const endDataMarker = " DATA -->"

const reportRetryTimeoutDuration = 5 * time.Minute
const reportRetryDelayDuration = 5 * time.Second

func UpdateIssue(ctx context.Context, owner, repoName, pat string, issue int, s State) error {
	client, err := githubutil.NewClient(ctx, pat)
	if err != nil {
		return err
	}

	startTime := time.Now()
	for {
		elapsed := time.Now().Sub(startTime)
		if elapsed > reportRetryTimeoutDuration {
			return fmt.Errorf("retry timeout %v expended", reportRetryTimeoutDuration)
		}

		// githubutil.Retry is designed to handle infra flakiness and rate limiting. We want this,
		// but we also want to handle potential concurrency issues. So: use two layers of retry.
		err := githubutil.Retry(func() error {
			syncRef, err := fetchLatestSyncRef(ctx, client, owner, repoName, issue)
			if err != nil {
				return err
			}
			log.Printf("sync hash: %#v\n", syncRef.GetObject().GetSHA())

			existingBody, err := getRefReport(ctx, client, owner, repoName, syncRef)
			if err != nil {
				return err
			}

			rc := parseReportComment(existingBody)
			rc.update(s)
			body, err := rc.body()
			if err != nil {
				return fmt.Errorf("unable to generate issue body: %v", err)
			}

			time.Sleep(time.Second * 2)

			if err := updateSyncRef(ctx, client, owner, repoName, body, syncRef); err != nil {
				return err
			}

			edit, _, err := client.Issues.Edit(ctx, owner, repoName, issue, &github.IssueRequest{
				Body: &body,
			})
			if err != nil {
				return err
			}

			log.Printf("Edit successful:\n%v\n", edit.ID)
			return nil
		})
		if err != nil {
			// Inner retry wasn't able to get the update done. This may be due to concurrency: N
			// builds trying to update the issue at the same time. Try again after a short delay.
			// (Nothing fancy: we aren't concerned about capacity contention. Even in the worst case
			// of N updates happening simultaneously, repeatedly, all concurrent updates will
			// eventually be able to get through because one update out of N succeeds each time.)
			log.Printf(
				"Inner GitHub retry loop failed. Waiting %v then trying again. Will give up after %v. Error: %v\n",
				reportRetryDelayDuration,
				reportRetryDelayDuration-elapsed,
				err)
			time.Sleep(reportRetryDelayDuration)
			continue
		}
		break // Success.
	}
	return nil
}

const syncRefName = "refs/sync/dev/report-bot"
const syncReportFile = "report.md"

func fetchLatestSyncRef(ctx context.Context, client *github.Client, owner, repoName string, issue int) (*github.Reference, error) {
	ref := fmt.Sprintf("%v/%v", syncRefName, issue)

	getRef, _, err := client.Git.GetRef(ctx, owner, repoName, ref)
	if err != nil {
		log.Printf("Failed to get ref, attempting to create it as an orphan branch. The failure was: %v\n", err)

		// Create a basic README because GitHub requires us to submit at least one file.
		path := "README.md"
		content := "This branch is used for 'releasego report' issue update synchronization."
		mode := "100644"
		tree, _, err := client.Git.CreateTree(ctx, owner, repoName, "", []github.TreeEntry{
			{Path: &path, Content: &content, Mode: &mode},
		})
		if err != nil {
			return nil, fmt.Errorf("failed to create tree for orphan branch: %v", err)
		}

		commit, _, err := client.Git.CreateCommit(ctx, owner, repoName, &github.Commit{
			Message: &ref,
			Tree:    tree,
		})
		if err != nil {
			return nil, fmt.Errorf("failed to create commit for orphan branch: %v", err)
		}

		newRef, _, err := client.Git.CreateRef(ctx, owner, repoName, &github.Reference{
			Ref: &ref,
			Object: &github.GitObject{
				SHA: commit.SHA,
			},
		})
		if err != nil {
			return nil, fmt.Errorf("failed to create ref for orphan branch %q %v: %v", ref, commit.GetSHA(), err)
		}
		log.Printf("Created ref %q at %q\n", ref, commit.GetSHA())
		return newRef, nil
	}
	return getRef, nil
}

func updateSyncRef(ctx context.Context, client *github.Client, owner, repoName, content string, syncRef *github.Reference) error {
	path := syncReportFile
	mode := "100644"
	tree, _, err := client.Git.CreateTree(ctx, owner, repoName, "", []github.TreeEntry{
		{Path: &path, Content: &content, Mode: &mode},
	})
	if err != nil {
		return err
	}

	message := "Update"
	commit, _, err := client.Git.CreateCommit(ctx, owner, repoName, &github.Commit{
		Parents: []github.Commit{
			{SHA: syncRef.GetObject().SHA},
		},
		Message: &message,
		Tree:    tree,
	})
	if err != nil {
		return err
	}

	note := fmt.Sprintf("update %v from %v to %v", syncRef.GetRef(), syncRef.GetObject().GetSHA(), commit.GetSHA())
	// Do a non-force push to fail if someone else got it done first.
	_, _, err = client.Git.UpdateRef(ctx, owner, repoName, &github.Reference{
		Ref: syncRef.Ref,
		Object: &github.GitObject{
			SHA: commit.SHA,
		},
	}, false)
	if err != nil {
		return fmt.Errorf("failed %v %v", note, err)
	}
	log.Printf("Completed: %v\n", note)
	return nil
}

func getRefReport(ctx context.Context, client *github.Client, owner, repoName string, ref *github.Reference) (string, error) {
	tree, _, err := client.Git.GetTree(ctx, owner, repoName, ref.GetObject().GetSHA(), false)
	if err != nil {
		return "", err
	}
	for _, e := range tree.Entries {
		if *e.Path == syncReportFile {
			content, _, err := client.Git.GetBlobRaw(ctx, owner, repoName, e.GetSHA())
			if err != nil {
				return "", err
			}
			return string(content), nil
		}
	}
	return "", nil
}

type State struct {
	// ID of the report. If an AzDO build, the AzDO Build ID.
	ID string
	// Version this report is associated with.
	Version string
	// Name of this type of report. If an AzDO build, the pipeline name.
	Name string
	// URL that the ID should link to. If an AzDO build, the main build page.
	URL string
	// Symbol represents the status.
	Symbol ReportSymbol

	LastUpdate time.Time
	StartTime  time.Time
}

type commentBody struct {
	before, after string
	reports       []State
}

func parseReportComment(body string) commentBody {
	before, report, after, found := cutTwice(body, beginDataSectionMarker, endDataSectionMarker)
	if found {
		if _, data, _, found := cutTwice(report, beginDataMarker, endDataMarker); found {
			r := make([]State, 0) // Unmarshal doesn't accept nil.
			err := json.Unmarshal([]byte(data), &r)
			if err != nil {
				log.Printf("Unable to read report data from comment: %v\n%v\n", err, data)
			}
			return commentBody{before, after, r}
		}
	}
	// Either the BEGIN/END markers couldn't be found, or DATA couldn't be found. Keep before and
	// after (if found), but ignore the content of the data section (if any).
	return commentBody{
		before: before,
		after:  after,
	}
}

func (c *commentBody) update(report State) {
	found := false
	for i := range c.reports {
		r := &c.reports[i]
		if r.ID == report.ID {
			// Update the found report by copying non-default fields.
			if report.Version != "" {
				r.Version = report.Version
			}
			if report.Name != "" {
				r.Name = report.Name
			}
			if report.URL != "" {
				r.URL = report.URL
			}
			if report.Symbol != "" {
				r.Symbol = report.Symbol
			}
			if report.LastUpdate != (time.Time{}) {
				r.LastUpdate = report.LastUpdate
			}
			if report.StartTime != (time.Time{}) {
				r.StartTime = report.StartTime
			}
			found = true
			break
		}
	}
	if !found {
		c.reports = append(c.reports, report)
	}
}

func (c *commentBody) body() (string, error) {
	var b strings.Builder
	b.WriteString(c.before)
	b.WriteString(beginDataSectionMarker)
	b.WriteString("\n\n")

	sort.SliceStable(c.reports, func(i, j int) bool {
		iv, jv := c.reports[i], c.reports[j]
		if c := strings.Compare(iv.Version, jv.Version); c != 0 {
			return c < 0
		}
		if c := strings.Compare(iv.Name, jv.Name); c != 0 {
			return c < 0
		}
		if c := strings.Compare(iv.ID, jv.ID); c != 0 {
			return c < 0
		}
		return false
	})

	var version, name string
	// Always start a new table for the first report, even if it has no version or no name.
	newTable := true
	for _, r := range c.reports {
		if r.Version != version {
			version = r.Version
			b.WriteString("\n## ")
			b.WriteString(version)
			b.WriteString("\n")
			name = ""
			newTable = true
		}
		if r.Name != name {
			name = r.Name
			b.WriteString("\n### ")
			b.WriteString(name)
			b.WriteString("\n\n")
			newTable = true
		}
		if newTable {
			newTable = false
			b.WriteString("| ID | Status | Started | Last Report |\n")
			b.WriteString("| --- | --- | --- | --- |\n")
		}
		b.WriteString("| ")
		if r.URL != "" {
			b.WriteString("[")
			b.WriteString(r.ID)
			b.WriteString("](")
			b.WriteString(r.URL)
			b.WriteString(")")
			b.WriteString(" | ")
			b.WriteString(string(r.Symbol))
			// If the build has failed (potentially needs retry) and is a release infra build
			// (likely publishes detailed retry information on the "Extensions" tab), then show a
			// direct link. This detection might not be 100% accurate, but it's just a small
			// convenience: it's ok to rely on a heuristic string match.
			if r.Symbol == ReportSymbolFailed && strings.HasPrefix(r.Name, "microsoft-go-infra-release-") {
				b.WriteString(" [Retry](")
				b.WriteString(r.URL)
				b.WriteString("&view=ms.vss-build-web.run-extensions-tab)")
			}
		}
		b.WriteString(" | ")
		if r.StartTime != (time.Time{}) {
			b.WriteString(r.StartTime.Format("2006-01-02 15:04"))
		}
		b.WriteString(" | ")
		if r.LastUpdate != (time.Time{}) {
			b.WriteString(r.LastUpdate.Format("2006-01-02 15:04"))
		}
		b.WriteString(" |")
		b.WriteString("\n")
	}
	b.WriteString("\n")

	b.WriteString(beginDataMarker)
	bytes, err := json.MarshalIndent(c.reports, "", "  ")
	if err != nil {
		b.WriteString("[]")
	} else {
		b.Write(bytes)
	}
	b.WriteString(endDataMarker)
	b.WriteString("\n")

	b.WriteString(endDataSectionMarker)
	b.WriteString(c.after)
	return b.String(), nil
}

func SingleStateBody(s *State) (string, error) {
	c := commentBody{reports: []State{*s}}
	return c.body()
}

func cutTwice(content, sep1, sep2 string) (before, between, after string, found bool) {
	if before1, after1, found := strings.Cut(content, sep1); found {
		if between, after2, found := strings.Cut(after1, sep2); found {
			return before1, between, after2, true
		}
	}
	return content, "", "", false
}
